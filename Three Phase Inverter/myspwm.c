/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 7.1.2   2018-01-07

The MIT License (MIT)
Copyright (c) 2009-2017 Atollic AB
******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"
#include "stm32f401_discovery.h"
#include "stm32f4xx_adc.h"

/* Private macro */
/* Private variables */
/* Private function prototypes */
/* Private functions */

/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int i=0;

//sinusoidal data for 256 point
const u16 PWMdata[256]={
		3750,3842,3934,4026,4118,4209,4300,4391,4482,4572,4661,4750,
		4839,4926,5013,5100,5185,5270,5353,5436,5518,5598,5678,5756,
		5833,5909,5984,6057,6129,6199,6268,6336,6402,6466,6529,6590,
		6649,6706,6762,6816,6868,6918,6966,7013,7057,7100,7140,7178,
		7215,7249,7281,7311,7339,7364,7388,7409,7428,7445,7459,7472,
		7482,7490,7495,7499,7500,7499,7495,7490,7482,7472,7459,7445,
		7428,7409,7388,7364,7339,7311,7281,7249,7215,7178,7140,7100,
		7057,7013,6966,6918,6868,6816,6762,6706,6649,6590,6529,6466,
		6402,6336,6268,6199,6129,6057,5984,5909,5833,5756,5678,5598,
		5518,5436,5353,5270,5185,5100,5013,4926,4839,4750,4661,4572,
		4482,4391,4300,4209,4118,4026,3934,3842,3750,3658,3566,3474,
		3382,3291,3200,3109,3018,2928,2839,2750,2661,2574,2487,2400,
		2315,2230,2147,2064,1982,1902,1822,1744,1667,1591,1516,1443,
		1371,1301,1232,1164,1098,1034,971,910,851,794,738,684,
		632,582,534,487,443,400,360,322,285,251,219,189,
		161,136,112,91,72,55,41,28,18,10,5,1,
		0,1,5,10,18,28,41,55,72,91,112,136,
		161,189,219,251,285,322,360,400,443,487,534,582,
		632,684,738,794,851,910,971,1034,1098,1164,1232,1301,
		1371,1443,1516,1591,1667,1744,1822,1902,1982,2064,2147,2230,
		2315,2400,2487,2574,2661,2750,2839,2928,3018,3109,3200,3291,
		3382,3474,3566,3658,3750
};
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef TIM_OCInitStructure;
GPIO_InitTypeDef GPIO_InitStructure;
TIM_BDTRInitTypeDef TIM_BDTRInitStructure;

ErrorStatus HSEStartUpStatus;

/* Private function prototypes -----------------------------------------------*/
void RCC_Configuration(void);
void GPIO_Configuration(void);
void NVIC_Configuration(void);

int main(void)
{
	#ifdef DEBUG
		debug();
	#endif
	/* System Clocks Configuration */
	RCC_Configuration();
	//SystemInit();
	/* TIM1, GPIOA and GPIOB clock enable */
	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA |RCC_AHB1Periph_GPIOB|RCC_AHB1Periph_GPIOE,ENABLE);

	NVIC_Configuration();
	GPIO_Configuration();
	TM_CONFIGURATION();


	while (1)
	{

	}
}

void TM_CONFIGURATION(void)
{
	/* TIM1 Configuration ---------------------------------------------------
		Generates 6 complemantary PWM signals with 4 sinusoidal data duty cycles:
		TIM1CLK = 72 MHz, Prescaler = 0, TIM1 counter clock = 72 MHz
		TIM1 frequency = TIM1CLK/(TIM1_Period + 1) =
		Time Base configuration */

		/* TIM1 Peripheral Configuration ----------------------------------------*/
		/* Time Base configuration */
		TIM_TimeBaseStructure.TIM_Prescaler = 0;
		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
		TIM_TimeBaseStructure.TIM_Period = 7500-1;		//15200Hz
		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
		TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;

		TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);

		/* Channel 3 Configuration in PWM mode */
		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
		TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
		TIM_OCInitStructure.TIM_Pulse = PWMdata[0];//127;
		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
		TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
		TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
		TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

		TIM_OC3Init(TIM1, &TIM_OCInitStructure);

		/* Channel 2 Configuration in PWM mode */
		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
		TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
		TIM_OCInitStructure.TIM_Pulse = PWMdata[0];//127;
		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
		TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
		TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
		TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

		TIM_OC2Init(TIM1, &TIM_OCInitStructure);

		/* Channel 1 Configuration in PWM mode */
		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
		TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
		TIM_OCInitStructure.TIM_Pulse = PWMdata[5];//127;
		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
		TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
		TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
		TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

		TIM_OC1Init(TIM1, &TIM_OCInitStructure);

		/* Automatic Output enable, Break, dead time and lock configuration*/
		TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
		TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
		TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1;
		TIM_BDTRInitStructure.TIM_DeadTime = 5;
		TIM_BDTRInitStructure.TIM_Break = TIM_Break_Disable;
		TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;
		TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;

		TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
		TIM_ClearFlag(TIM1, TIM_FLAG_CC1);
		//TIM1 interrupt source
		TIM_ITConfig(TIM1, TIM_IT_CC1, ENABLE);
		TIM_Cmd(TIM1, ENABLE);

		/* Main Output Enable */
		TIM_CtrlPWMOutputs(TIM1, ENABLE);
}
/*******************************************************************************
* Function Name : RCC_Configuration
* Description : Configures the different system clocks.
* Input : None
* Output : None
* Return : None
*******************************************************************************/
void RCC_Configuration(void)
{
	/* RCC system reset(for debug purpose) */
	RCC_DeInit();

	/* Enable HSE */
	RCC_HSEConfig(RCC_HSE_ON);

	/* Wait till HSE is ready */
	HSEStartUpStatus = RCC_WaitForHSEStartUp();

	if (HSEStartUpStatus == SUCCESS)
	{
	/* Enable Prefetch Buffer */
	//FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);

	/* Flash 2 wait state */
	FLASH_SetLatency(FLASH_Latency_2);

	/* HCLK = SYSCLK */
	RCC_HCLKConfig(RCC_SYSCLK_Div1);

	/* PCLK2 = HCLK */
	RCC_PCLK2Config(RCC_HCLK_Div1);

	/* PCLK1 = HCLK/2 */
	RCC_PCLK1Config(RCC_HCLK_Div2);

	/* ADCCLK = PCLK2/4 */
	//RCC_ADCCLKConfig(RCC_PCLK2_Div6);

	/* PLLCLK = 8MHz * 9 = 72 MHz */
	//RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);

	/* Enable PLL */
	RCC_PLLCmd(ENABLE);

	/* Wait till PLL is ready */
	while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
	{}

	/* Select PLL as system clock source */
	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);

	/* Wait till PLL is used as system clock source */
	while (RCC_GetSYSCLKSource() != 0x08)
	{}
	}

	}
/*******************************************************************************
* Function Name : GPIO_Configuration
* Description : Configure the TIM1 Pins.
* Input : None
* Output : None
* Return : None
*******************************************************************************/
void GPIO_Configuration(void)
{


	GPIO_InitTypeDef GPIO_InitStructure;

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource8, GPIO_AF_TIM1);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_TIM1);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_TIM1);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_TIM1);

	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOA, &GPIO_InitStructure);


	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_TIM1);
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_TIM1);
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_TIM1);

	/* GPIOB Configuration: Channel 1N, 2N and 3N as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_TIM1);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
}

/*******************************************************************************
* Function Name : NVIC_Configuration
* Description : Configures Vector Table base location.
* Input : None
* Output : None
* Return : None
*******************************************************************************/
void NVIC_Configuration(void)
{
	NVIC_InitTypeDef NVIC_InitStructure;

	#ifdef VECT_TAB_RAM
	/* Set the Vector Table base location at 0x20000000 */
	NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
	#else /* VECT_TAB_FLASH */
	/* Set the Vector Table base location at 0x08000000 */
	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
	#endif

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	NVIC_InitStructure.NVIC_IRQChannel = TIM1_CC_IRQn;
	//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}
#ifdef DEBUG
/*******************************************************************************
* Function Name : assert_failed
* Description : Reports the name of the source file and the source line number
* where the assert_param error has occurred.
* Input : - file: pointer to the source file name
* - line: assert_param error line source number
* Output : None
* Return : None
*******************************************************************************/
void assert_failed(u8* file, u32 line)
{
/* User can add his own implementation to report the file name and line number,
ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

while (1)
{

}
}
#endif

/******************* *****END OF FILE****/

void TIM1_CC_IRQHandler(void)
{
	i++;
	TIM_OCInitStructure.TIM_Pulse = PWMdata[i];
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
	TIM_OCInitStructure.TIM_Pulse = PWMdata[(i+86)%256];
	TIM_OC2Init(TIM1, &TIM_OCInitStructure);
	TIM_OCInitStructure.TIM_Pulse = PWMdata[(i+171)%256];
	TIM_OC3Init(TIM1, &TIM_OCInitStructure);

	/* check if array's index reaches the max: 255 */
	if (i == 255)
	{
		i = 0;
	}
	TIM_ClearFlag(TIM1,TIM_FLAG_CC1);
}
